neuralnetwork = {
//==========================================================================================
        //Full path to the file with input data for training, must be in the required format
        // (specified in the readme file)
//==========================================================================================

        nameTrainIn        = "./input/minCubeParihaka.txt";

//==========================================================================================
        //Full path to the folder with the input data (test), used (target variable),
        //must be in the required format (specified in the readme file)
//==========================================================================================

        nameTestIn         = "./input/minCubeParihaka.txt";

//==========================================================================================
        //Save folder
//==========================================================================================

        saveFolder         ="./output/";

//==========================================================================================
        //Full path to a folder (no slash at the end) with weights to initialise 
        // (if weightsInitFlag == 1) Weights must have names: weights0.dat ... weightsn.dat
        // if some are missing, these will stay random 
//==========================================================================================

        weightsInit        = "";

//==========================================================================================
        //Full path to the folder with the test mask
        //must be in the required format (specified in the readme file)
//==========================================================================================

        nameMaskTest       = "./input/mask128x128/mask30noise.txt";

//==========================================================================================
        //Full path to the folder with the validation mask
        //must be in the required format (specified in the readme file)
//==========================================================================================

        nameMaskValidation = "./input/mask128x128/mask1noise.txt";

//==========================================================================================
        //Flag specifing maks: 0.0 - no test mask, 1.0 - test mask
//==========================================================================================

        maskFlagTest       = 1.0;

//==========================================================================================
        //Flag specifing maks: 0.0 - no validation mask, 1.0 - validation mask
//==========================================================================================

        maskFlagValidation = 1.0;

//==========================================================================================
        //Flag specifing initialisation: 0 - random, 1 - from a file
//==========================================================================================

        weightsInitFlag    = 0;

//==========================================================================================
        //Number of training epochs
//==========================================================================================

        numbEpoches        = 1000;

//==========================================================================================
        //Number of test iterations (no more than the number of instances in the test input 
        // file
//==========================================================================================

        numbItTest         = 32768;

//==========================================================================================
        //Size of the augmentation band around a patch.
//==========================================================================================

        augment            = 0;

//==========================================================================================
        //Number of train iterations (no more than the number of instances in the train  
        // input file
//==========================================================================================

        numbItTrain        = 8192;

//==========================================================================================
        //Number of validation iterations (no more than the number of instances in the train)
//==========================================================================================

        numbItValidation   = 256;

//==========================================================================================
        //Size of the patch [Z, Y, X]
//==========================================================================================

        patch              = [1, 8, 8];

//==========================================================================================
        //Size of the patch shift while testing [Z, Y, X]. If equal to the patch size, no 
        //overlaps
//==========================================================================================

        shiftTest          = [1, 8, 8];

//==========================================================================================
        //Size of the patch shift while training [Z, Y, X]. If equal to the patch size, no 
        //overlaps
//==========================================================================================

        shiftTrain         = [1, 8, 8];

//==========================================================================================
        //Number of layers: input+output+#hidden layers 
//==========================================================================================

        numbLayers         = 3;

//==========================================================================================
        //Sizes of the layers (input and output dimensions must be the same as in the input 
        // data files
//==========================================================================================

        layers             = [64, 32, 64];

//==========================================================================================
        //Activation functions in every layer (must have the same number as the number of 
        // layers): 1 - rectifier, 2 - sigmoid, 3 -softPlus, 4 -inversetan, 5 - linear, 
        // 6 - gausean, 7 - steprectifier.
//==========================================================================================

        actFunctions       = [5, 4, 5];

//==========================================================================================
        //Mini-batch size
//==========================================================================================

        miniBatch          = 16;

//==========================================================================================
        //Learning rate
//==========================================================================================

        learningRate       = 0.01;

//==========================================================================================
        //Lower and upper bound for the dynamic learning rate (static if bounds are equal
        // the learning rate)
//==========================================================================================


        dynamicLearningR   = [0.01,0.01];

//==========================================================================================
        //Flag if 1 the algorithm takes the reconstructed data and feeds it throught the network
        //again, reconstructed predictions are used instead of 0s;
//==========================================================================================

        polishing = 0;

//==========================================================================================
        //Either 1.0 or 0.0 - flag to assign more weight to the error on patch edges
//==========================================================================================

        weightedErrorFlag  = 0;

//==========================================================================================
        // 0.0 - no drop out, 1.0 - all hidden neurons are set to 0, 0.3 - 30% are set to 0            
//==========================================================================================

        dropOut            = 0.0;

//==========================================================================================
        // Flag (0 or 1). If 0 no curriculum learning is used 1 --> 1 example is added per 
        // epoch            
//==========================================================================================

        curriculum         = 0;

//==========================================================================================
        // max value of the neuron activation expected            
//==========================================================================================

        sparcityParameter  = 0.0;

//==========================================================================================
        // strength of regularization if sparse auto-encoder is used            
//==========================================================================================

        sparse             = 0.0;

//==========================================================================================
        // range between 0.001 to 0.000001
//==========================================================================================    

        annealing          = 0.0;
        //learningRate=learningRate*(1.0/(1.0+annealing*epoch))

//==========================================================================================
        //Learning rate 0 - Least Squares, 1 - Huber Loss, 2 - linear, 3 - ssim
//==========================================================================================

        objective          = 0;

//==========================================================================================
        //Value of Delta in huberDelta
//==========================================================================================

        huberDelta         = 0.0;

//==========================================================================================
        //Momentum [0.0,1.0) if 0.0 no momentum
//==========================================================================================

        momentum           = 0.0;

//==========================================================================================
        //Adagrad if 0.0 no Adagrad
//==========================================================================================

        adaGrad            = 0.0;

//==========================================================================================
        //Strength of regularization in the contracting auto-encoder
//==========================================================================================

        lambda             = 0.0;

//==========================================================================================
        //Shuffle the data in every iteration?
//==========================================================================================

        shuffleFlag        = 1;

//==========================================================================================
        //Gather statistics about the activation of the neurons
//==========================================================================================

        statsFlag          = 1;

//==========================================================================================
       //Random initialisation of the input (float): 0.0 - all weights are set to 0.001, 
        // 1.0 - all weights are randomly initialised
//==========================================================================================       

        randomFlag         = 1.0;

//==========================================================================================
        //Scaling the input data: -1.0 (x/maxAbs(data)); -2.0 (x-minData/(maxDat-minData));
        // c = (0; +inf) (x*c)
//==========================================================================================

        inputScale         = -1.0;

//==========================================================================================
       // Scale of the random initialisation
//==========================================================================================
  
        weightMagnitude    = 0.001;

//==========================================================================================
        // 0 - no weight freezing   1 - freeze encoder for fractionOfEpochs 2 - freeze deco
        // der for fractionOfEpochs 3 -freeze decoder for fractionOfEpochs and then freeze 
        // encoder for fractionOfEpochs, the remaining of time both trained together
//==========================================================================================

        weightFreezeFlag   = 0;

//==========================================================================================
         // Freeze weights for a fraction of epochs                   
//==========================================================================================

        fractionOfEpochs   = 0.0;

//==========================================================================================
        //Bias (float number, usual choice is 0.0 or 1.0)
//==========================================================================================

        bias               = 1.0;

}
